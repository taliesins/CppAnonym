#include "stdafx.h"

#ifndef URASANDESU_CPPANONYM_UTILITIES_ISANYT_HPP
#include <Urasandesu/CppAnonym/Utilities/IsAnyT.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_TRAITS_PREDICATABLE_HPP
#include <Urasandesu/CppAnonym/Traits/Predicatable.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_UTILITIES_EQUALTO_HPP
#include <Urasandesu/CppAnonym/Utilities/EqualTo.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_TRAITS_EQUALITYCOMPARABLE_HPP
#include <Urasandesu/CppAnonym/Traits/EqualityComparable.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_TRAITS_HASHCOMPUTABLE_HPP
#include <Urasandesu/CppAnonym/Traits/HashComputable.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_OBJECTTAG_HPP
#include <Urasandesu/CppAnonym/ObjectTag.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_UTILITIES_DESTRUCTIONDISTRIBUTOR_HPP
#include <Urasandesu/CppAnonym/Utilities/DestructionDistributor.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_SIMPLEHEAP_HPP
#include <Urasandesu/CppAnonym/SimpleHeap.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_SIMPLEHEAPPROVIDER_HPP
#include <Urasandesu/CppAnonym/SimpleHeapProvider.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_CPPANONYMEXCEPTION_H
#include <Urasandesu/CppAnonym/CppAnonymException.h>
#endif

#ifndef URASANDESU_CPPANONYM_CPPANONYMNOTIMPLEMENTEDEXCEPTION_H
#include <Urasandesu/CppAnonym/CppAnonymNotImplementedException.h>
#endif

#ifndef URASANDESU_CPPANONYM_CPPANONYMCOMEXCEPTION_H
#include <Urasandesu/CppAnonym/CppAnonymCOMException.h>
#endif

#ifndef URASANDESU_CPPANONYM_CPPANONYMSYSTEMEXCEPTION_H
#include <Urasandesu/CppAnonym/CppAnonymSystemException.h>
#endif

#ifndef URASANDESU_CPPANONYM_UTILITIES_ANYPOINTER_H
#include <Urasandesu/CppAnonym/Utilities/AnyPointer.h>
#endif

#ifndef URASANDESU_CPPANONYM_HEAPPROVIDER_HPP
#include <Urasandesu/CppAnonym/HeapProvider.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_BASETYPENAMEMETADATA_HPP
#include <Urasandesu/CppAnonym/Metadata/BaseTypeNameMetadata.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_TYPEKINDS_H
#include <Urasandesu/CppAnonym/Metadata/TypeKinds.h>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_CALLINGCONVENTIONS_H
#include <Urasandesu/CppAnonym/Metadata/CallingConventions.h>
#endif

#ifndef URASANDESU_CPPANONYM_FUSION_BASEFUSIONINFO_HPP
#include <Urasandesu/CppAnonym/Fusion/BaseFusionInfo.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_FUSION_INTERFACES_FUSIONINFOLABEL_HPP
#include <Urasandesu/CppAnonym/Fusion/Interfaces/FusionInfoLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_TRAITS_CARTRIDGEAPISYSTEM_HPP
#include <Urasandesu/CppAnonym/Traits/CartridgeApiSystem.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_UTILITIES_CCOMOBJECTSLIM_HPP
#include <Urasandesu/CppAnonym/Utilities/CComObjectSlim.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_FUSION_ASSEMBLYINFO_H
#include <Urasandesu/CppAnonym/Fusion/AssemblyInfo.h>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_METADATAINFOLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/MetadataInfoLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_METADATADISPENSERAPIHOLDERLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/MetadataDispenserApiHolderLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_ASSEMBLYMETADATAAPIHOLDERLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/AssemblyMetadataApiHolderLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_ASSEMBLYNAMEMETADATAAPIHOLDERLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/AssemblyNameMetadataApiHolderLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_TYPEMETADATAAPIHOLDERLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/TypeMetadataApiHolderLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_TYPENAMEMETADATAAPIHOLDERLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/TypeNameMetadataApiHolderLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_METHODMETADATAAPIHOLDERLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/MethodMetadataApiHolderLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_METHODNAMEMETADATAAPIHOLDERLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/MethodNameMetadataApiHolderLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_METADATADISPENSERLABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/MetadataDispenserLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_ASSEMBLYNAMEMETADATALABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/AssemblyNameMetadataLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_TYPENAMEMETADATALABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/TypeNameMetadataLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_INTERFACES_METHODNAMEMETADATALABEL_HPP
#include <Urasandesu/CppAnonym/Metadata/Interfaces/MethodNameMetadataLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_BASEMETADATADISPENSER_HPP
#include <Urasandesu/CppAnonym/Metadata/BaseMetadataDispenser.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_BASEASSEMBLYMETADATA_HPP
#include <Urasandesu/CppAnonym/Metadata/BaseAssemblyMetadata.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_BASEASSEMBLYNAMEMETADATA_HPP
#include <Urasandesu/CppAnonym/Metadata/BaseAssemblyNameMetadata.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_BASETYPEMETADATA_HPP
#include <Urasandesu/CppAnonym/Metadata/BaseTypeMetadata.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_IMETADATAIMPORT2IMPL_HPP
#include <Urasandesu/CppAnonym/Metadata/IMetaDataImport2Impl.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_BASEMETHODMETADATA_HPP
#include <Urasandesu/CppAnonym/Metadata/BaseMethodMetadata.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_METADATA_BASEMETHODNAMEMETADATA_HPP
#include <Urasandesu/CppAnonym/Metadata/BaseMethodNameMetadata.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_STRONGNAMING_INTERFACES_STRONGNAMEINFOLABEL_HPP
#include <Urasandesu/CppAnonym/StrongNaming/Interfaces/StrongNameInfoLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_STRONGNAMING_BASESTRONGNAMEINFO_HPP
#include <Urasandesu/CppAnonym/StrongNaming/BaseStrongNameInfo.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_STRONGNAMING_INTERFACES_STRONGNAMEKEYLABEL_HPP
#include <Urasandesu/CppAnonym/StrongNaming/Interfaces/StrongNameKeyLabel.hpp>
#endif

#ifndef URASANDESU_CPPANONYM_STRONGNAMING_BASESTRONGNAMEKEY_HPP
#include <Urasandesu/CppAnonym/StrongNaming/BaseStrongNameKey.hpp>
#endif


// Forward Declarations
namespace Mock9254318F {

    class ATL_NO_VTABLE MockMetaDataImport;
    typedef Urasandesu::CppAnonym::Utilities::CComObjectSlim<MockMetaDataImport> MockMetaDataImportObject;

}   // namespace Mock9254318F {

namespace Mock9254318F {
    
    typedef std::vector<boost::any> AnyVector;

    class MockMetadataInfo
    {
    public:
        template<class T>
        T const *FindType() const 
        {
            using namespace boost;
            using namespace Urasandesu::CppAnonym::Utilities;

            AnyVector::iterator result;
            result = std::find_if(m_typePtrs.begin(), m_typePtrs.end(), IsAnyT<shared_ptr<T> >()); 
            _ASSERTE(result != m_typePtrs.end());

            return any_cast<shared_ptr<T> >(*result).get();
        }

        mutable AnyVector m_typePtrs;
    };

    class MockRuntimeHost
    {
    public:
        boost::filesystem::path const &GetCORSystemDirectoryPath() const
        {
            return m_corSystemDirectoryPath;
        }

        mutable boost::filesystem::path m_corSystemDirectoryPath;
    };

    class ATL_NO_VTABLE MockMetaDataImport : 
        public ATL::CComObjectRootEx<ATL::CComSingleThreadModel>,
        public Urasandesu::CppAnonym::Metadata::IMetaDataImport2Impl<IMetaDataImport2>
    {
    public:
        MockMetaDataImport() { }

    BEGIN_COM_MAP(MockMetaDataImport)
        COM_INTERFACE_ENTRY_IID(IID_IMetaDataImport2, IMetaDataImport2)
    END_COM_MAP()

        DECLARE_PROTECT_FINAL_CONSTRUCT()

        HRESULT FinalConstruct() { return S_OK; }
        void FinalRelease() { }
    };

    struct TestApiHolder;

    namespace Detail {

        using namespace boost::mpl;
        using namespace Urasandesu::CppAnonym::Fusion;
        using namespace Urasandesu::CppAnonym::Fusion::Interfaces;
        using namespace Urasandesu::CppAnonym::Metadata;
        using namespace Urasandesu::CppAnonym::Metadata::Interfaces;
        using namespace Urasandesu::CppAnonym::Hosting;
        using namespace Urasandesu::CppAnonym::Hosting::Interfaces;
        using namespace Urasandesu::CppAnonym::StrongNaming;
        using namespace Urasandesu::CppAnonym::StrongNaming::Interfaces;

        struct TestApiHolderImpl
        {
            typedef map<
                pair<MetadataDispenserLabel, BaseMetadataDispenser<TestApiHolder> >, 
                pair<AssemblyMetadataLabel, BaseAssemblyMetadata<TestApiHolder> >, 
                pair<AssemblyNameMetadataLabel, BaseAssemblyNameMetadata<TestApiHolder> >, 
                pair<AssemblyNameMetadataHashLabel, BaseAssemblyNameMetadataHash<TestApiHolder> >, 
                pair<AssemblyNameMetadataEqualToLabel, BaseAssemblyNameMetadataEqualTo<TestApiHolder> >, 
                pair<TypeMetadataLabel, BaseTypeMetadata<TestApiHolder> >, 
                pair<TypeNameMetadataLabel, BaseTypeNameMetadata<TestApiHolder> >, 
                pair<TypeNameMetadataHashLabel, BaseTypeNameMetadataHash<TestApiHolder> >, 
                pair<TypeNameMetadataEqualToLabel, BaseTypeNameMetadataEqualTo<TestApiHolder> >, 
                pair<MethodMetadataLabel, BaseMethodMetadata<TestApiHolder> >, 
                pair<MethodNameMetadataLabel, BaseMethodNameMetadata<TestApiHolder> >,
                pair<MethodNameMetadataHashLabel, BaseMethodNameMetadataHash<TestApiHolder> >,
                pair<MethodNameMetadataEqualToLabel, BaseMethodNameMetadataEqualTo<TestApiHolder> >,                 
                pair<RuntimeHostLabel, Mock9254318F::MockRuntimeHost>, 
                pair<MetadataInfoLabel, Mock9254318F::MockMetadataInfo>, 
                pair<FusionInfoLabel, BaseFusionInfo<TestApiHolder> >,
                pair<StrongNameKeyLabel, BaseStrongNameKey<TestApiHolder> >, 
                pair<StrongNameInfoLabel, BaseStrongNameInfo<TestApiHolder> >, 
                pair<IMetaDataDispenserEx, IMetaDataDispenserEx>,
                pair<IMetaDataAssemblyImport, IMetaDataAssemblyImport>,
                pair<IMetaDataImport2, IMetaDataImport2> 
            > api_cartridges;
        };

    }   // namespace Detail {

    struct TestApiHolder : 
        Detail::TestApiHolderImpl
    {
    };

}   // namespace Mock9254318F {

// Test.Urasandesu.CppAnonym.exe --gtest_filter=Urasandesu_CppAnonym_Metadata_Test.*
namespace {


    CPPANONYM_TEST(Urasandesu_CppAnonym_Metadata_Test, CombinationOfResolutionWayTest_All_01)
    {
        namespace mpl = boost::mpl;
        using namespace boost;
        using namespace Urasandesu::CppAnonym;
        using namespace Urasandesu::CppAnonym::Fusion;
        using namespace Urasandesu::CppAnonym::Metadata;
        using namespace Urasandesu::CppAnonym::Hosting;
        using namespace Urasandesu::CppAnonym::StrongNaming;

        typedef Mock9254318F::MockRuntimeHost RuntimeHost; 
        typedef Mock9254318F::MockMetadataInfo MetadataInfo;
        typedef BaseFusionInfo<Mock9254318F::TestApiHolder> FusionInfo;

        typedef BaseMetadataDispenser<Mock9254318F::TestApiHolder> MetadataDispenser;
        typedef BaseAssemblyMetadata<Mock9254318F::TestApiHolder> AssemblyMetadata;
        typedef BaseAssemblyNameMetadata<Mock9254318F::TestApiHolder> AssemblyNameMetadata;
        typedef BaseTypeMetadata<Mock9254318F::TestApiHolder> TypeMetadata;
        typedef BaseTypeNameMetadata<Mock9254318F::TestApiHolder> TypeNameMetadata;
        typedef BaseMethodMetadata<Mock9254318F::TestApiHolder> MethodMetadata;
        typedef BaseMethodNameMetadata<Mock9254318F::TestApiHolder> MethodNameMetadata;

        shared_ptr<RuntimeHost> pRuntimeHost(make_shared<RuntimeHost>());
        pRuntimeHost->m_corSystemDirectoryPath = L"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\";

        shared_ptr<FusionInfo> pFusionInfo(make_shared<FusionInfo>());
        pFusionInfo->Init(*pRuntimeHost);

        shared_ptr<MetadataInfo> pMetaInfo(make_shared<MetadataInfo>());
        pMetaInfo->m_typePtrs.push_back(pFusionInfo);
        
        shared_ptr<MetadataDispenser> pMetaDisp(make_shared<MetadataDispenser>());
        pMetaDisp->Init(*pMetaInfo);

        AssemblyNameMetadata *pMSCorLibName = NULL;
        {
            std::wstring name(L"mscorlib, Version=2.0.0.0, Culture=neutral, " 
                              L"PublicKeyToken=b77a5c561934e089, processorArchitecture=x86");
            pMSCorLibName = pMetaDisp->NewAssemblyName(name);
        }

        ASSERT_STREQ(L"mscorlib, Version=2.0.0.0, Culture=neutral, " 
                     L"PublicKeyToken=b77a5c561934e089, processorArchitecture=x86", pMSCorLibName->GetName().c_str());
        
        AssemblyMetadata const *pMSCorLib = NULL;
        pMSCorLib = pMSCorLibName->Resolve();
        ASSERT_EQ(0x20000001, pMSCorLib->GetToken());
        
        TypeNameMetadata *pConsoleName = NULL;
        {
            std::wstring name(L"System.Console");
            TypeKinds kind(TypeKinds::TK_CLASS);
            pConsoleName = pMSCorLibName->NewTypeName(name, kind);
        }

        ASSERT_STREQ(L"System.Console", pConsoleName->GetName().c_str());

        TypeMetadata const *pConsole = NULL;
        pConsole = pConsoleName->Resolve();
        ASSERT_EQ(0x02000089, pConsole->GetToken());

        MethodNameMetadata *pWriteLineName = NULL;
        {
            std::wstring name(L"WriteLine");
            CallingConventions callingConvention(CallingConventions::CC_STANDARD);
            TypeNameMetadata const *pRetTypeName = pMSCorLibName->NewTypeName(L"System.Void", TypeKinds::TK_VOID);
            std::vector<TypeNameMetadata const *> paramTypeNames;
            paramTypeNames.push_back(pMSCorLibName->NewTypeName(L"System.String", TypeKinds::TK_STRING));
            pWriteLineName = pConsoleName->NewMethodName(name, callingConvention, *pRetTypeName, paramTypeNames);
        }
    }



    CPPANONYM_TEST(Urasandesu_CppAnonym_Metadata_Test, CombinationOfResolutionWayTest_FromAssembly_01)
    {
        namespace mpl = boost::mpl;
        namespace fs = boost::filesystem;
        using namespace boost;
        using namespace Urasandesu::CppAnonym;
        using namespace Urasandesu::CppAnonym::Fusion;
        using namespace Urasandesu::CppAnonym::Metadata;

        typedef Mock9254318F::MockRuntimeHost RuntimeHost; 
        typedef Mock9254318F::MockMetadataInfo MetadataInfo;
        typedef BaseFusionInfo<Mock9254318F::TestApiHolder> FusionInfo;

        typedef BaseMetadataDispenser<Mock9254318F::TestApiHolder> MetadataDispenser;
        typedef BaseAssemblyMetadata<Mock9254318F::TestApiHolder> AssemblyMetadata;
        typedef BaseAssemblyNameMetadata<Mock9254318F::TestApiHolder> AssemblyNameMetadata;
        typedef BaseTypeMetadata<Mock9254318F::TestApiHolder> TypeMetadata;
        typedef BaseTypeNameMetadata<Mock9254318F::TestApiHolder> TypeNameMetadata;
        typedef BaseMethodMetadata<Mock9254318F::TestApiHolder> MethodMetadata;
        typedef BaseMethodNameMetadata<Mock9254318F::TestApiHolder> MethodNameMetadata;

        shared_ptr<RuntimeHost> pRuntimeHost(make_shared<RuntimeHost>());
        pRuntimeHost->m_corSystemDirectoryPath = L"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\";

        shared_ptr<FusionInfo> pFusionInfo(make_shared<FusionInfo>());
        pFusionInfo->Init(*pRuntimeHost);

        shared_ptr<MetadataInfo> pMetaInfo(make_shared<MetadataInfo>());
        pMetaInfo->m_typePtrs.push_back(pFusionInfo);
        
        shared_ptr<MetadataDispenser> pMetaDisp(make_shared<MetadataDispenser>());
        pMetaDisp->Init(*pMetaInfo);

        AssemblyMetadata const *pMSCorLib = NULL;
        {
            fs::path asmPath(L"C:\\windows\\assembly\\GAC_32\\mscorlib\\2.0.0.0__b77a5c561934e089\\mscorlib.dll");
            pMSCorLib = pMetaDisp->LoadAssemblyFromFile(asmPath);
        }

        AssemblyNameMetadata const *pMSCorLibName = NULL;
        pMSCorLibName = pMSCorLib->GetAssemblyName();

        TypeNameMetadata *pConsoleName = NULL;
        {
            std::wstring name(L"System.Console");
            TypeKinds kind(TypeKinds::TK_CLASS);
            pConsoleName = pMSCorLib->NewTypeName(name, kind);
        }

        ASSERT_STREQ(L"System.Console", pConsoleName->GetName().c_str());

        TypeMetadata const *pConsole = NULL;
        pConsole = pConsoleName->Resolve();
        ASSERT_EQ(0x02000089, pConsole->GetToken());
    }



    CPPANONYM_TEST(Urasandesu_CppAnonym_Metadata_Test, CombinationOfResolutionWayTest_FromType_01)
    {
        namespace fs = boost::filesystem;
        namespace mpl = boost::mpl;
        using namespace boost;
        using namespace Urasandesu::CppAnonym;
        using namespace Urasandesu::CppAnonym::Fusion;
        using namespace Urasandesu::CppAnonym::Metadata;

        typedef Mock9254318F::MockRuntimeHost RuntimeHost; 
        typedef Mock9254318F::MockMetadataInfo MetadataInfo;
        typedef BaseFusionInfo<Mock9254318F::TestApiHolder> FusionInfo;

        typedef BaseMetadataDispenser<Mock9254318F::TestApiHolder> MetadataDispenser;
        typedef BaseAssemblyMetadata<Mock9254318F::TestApiHolder> AssemblyMetadata;
        typedef BaseAssemblyNameMetadata<Mock9254318F::TestApiHolder> AssemblyNameMetadata;
        typedef BaseTypeMetadata<Mock9254318F::TestApiHolder> TypeMetadata;
        typedef BaseTypeNameMetadata<Mock9254318F::TestApiHolder> TypeNameMetadata;
        typedef BaseMethodMetadata<Mock9254318F::TestApiHolder> MethodMetadata;
        typedef BaseMethodNameMetadata<Mock9254318F::TestApiHolder> MethodNameMetadata;

        shared_ptr<RuntimeHost> pRuntimeHost(make_shared<RuntimeHost>());
        pRuntimeHost->m_corSystemDirectoryPath = L"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\";

        shared_ptr<FusionInfo> pFusionInfo(make_shared<FusionInfo>());
        pFusionInfo->Init(*pRuntimeHost);

        shared_ptr<MetadataInfo> pMetaInfo(make_shared<MetadataInfo>());
        pMetaInfo->m_typePtrs.push_back(pFusionInfo);
        
        shared_ptr<MetadataDispenser> pMetaDisp(make_shared<MetadataDispenser>());
        pMetaDisp->Init(*pMetaInfo);

        AssemblyMetadata const *pMSCorLib = NULL;
        {
            fs::path asmPath(L"C:\\windows\\assembly\\GAC_32\\mscorlib\\2.0.0.0__b77a5c561934e089\\mscorlib.dll");
            pMSCorLib = pMetaDisp->LoadAssemblyFromFile(asmPath);
        }

        TypeMetadata const *pConsole = NULL;
        {
            std::wstring name(L"System.Console");
            pConsole = pMSCorLib->GetType(name);
        }

        TypeNameMetadata const *pConsoleName = NULL;
        pConsoleName = pConsole->GetTypeName();

        ASSERT_STREQ(L"System.Console", pConsoleName->GetName().c_str());

        MethodNameMetadata *pWriteLineName = NULL;
        {
            std::wstring name(L"WriteLine");
            CallingConventions callingConvention(CallingConventions::CC_STANDARD);
            TypeNameMetadata const *pRetTypeName = pMSCorLib->NewTypeName(L"System.Void", TypeKinds::TK_VOID);
            std::vector<TypeNameMetadata const *> paramTypeNames;
            paramTypeNames.push_back(pMSCorLib->NewTypeName(L"System.String", TypeKinds::TK_STRING));
            pWriteLineName = pConsole->NewMethodName(name, callingConvention, *pRetTypeName, paramTypeNames);
        }

        ASSERT_STREQ(L"WriteLine", pWriteLineName->GetName().c_str());

        MethodMetadata const *pWriteLine = NULL;
        pWriteLine = pWriteLineName->Resolve();
        ASSERT_EQ(0x06000001, pWriteLine->GetToken());
    }



    CPPANONYM_TEST(Urasandesu_CppAnonym_Metadata_Test, CombinationOfResolutionWayTest_FromMethod_01)
    {
        namespace fs = boost::filesystem;
        namespace mpl = boost::mpl;
        using namespace boost;
        using namespace Urasandesu::CppAnonym;
        using namespace Urasandesu::CppAnonym::Fusion;
        using namespace Urasandesu::CppAnonym::Metadata;

        typedef Mock9254318F::MockRuntimeHost RuntimeHost; 
        typedef Mock9254318F::MockMetadataInfo MetadataInfo;
        typedef BaseFusionInfo<Mock9254318F::TestApiHolder> FusionInfo;

        typedef BaseMetadataDispenser<Mock9254318F::TestApiHolder> MetadataDispenser;
        typedef BaseAssemblyMetadata<Mock9254318F::TestApiHolder> AssemblyMetadata;
        typedef BaseAssemblyNameMetadata<Mock9254318F::TestApiHolder> AssemblyNameMetadata;
        typedef BaseTypeMetadata<Mock9254318F::TestApiHolder> TypeMetadata;
        typedef BaseTypeNameMetadata<Mock9254318F::TestApiHolder> TypeNameMetadata;
        typedef BaseMethodMetadata<Mock9254318F::TestApiHolder> MethodMetadata;
        typedef BaseMethodNameMetadata<Mock9254318F::TestApiHolder> MethodNameMetadata;

        shared_ptr<RuntimeHost> pRuntimeHost(make_shared<RuntimeHost>());
        pRuntimeHost->m_corSystemDirectoryPath = L"C:\\Windows\\Microsoft.NET\\Framework\\v2.0.50727\\";

        shared_ptr<FusionInfo> pFusionInfo(make_shared<FusionInfo>());
        pFusionInfo->Init(*pRuntimeHost);

        shared_ptr<MetadataInfo> pMetaInfo(make_shared<MetadataInfo>());
        pMetaInfo->m_typePtrs.push_back(pFusionInfo);
        
        shared_ptr<MetadataDispenser> pMetaDisp(make_shared<MetadataDispenser>());
        pMetaDisp->Init(*pMetaInfo);

        AssemblyMetadata const *pMSCorLib = NULL;
        {
            fs::path asmPath(L"C:\\windows\\assembly\\GAC_32\\mscorlib\\2.0.0.0__b77a5c561934e089\\mscorlib.dll");
            pMSCorLib = pMetaDisp->LoadAssemblyFromFile(asmPath);
        }

        TypeMetadata const *pConsole = NULL;
        {
            std::wstring name(L"System.Console");
            pConsole = pMSCorLib->GetType(name);
        }

        MethodMetadata const *pWriteLine = NULL;
        {
            std::wstring name(L"WriteLine");
            CallingConventions callingConvention(CallingConventions::CC_STANDARD);
            TypeMetadata const *pRetType = pMSCorLib->GetType(L"System.Void");
            std::vector<TypeMetadata const *> paramTypes;
            paramTypes.push_back(pMSCorLib->GetType(L"System.String"));
            pWriteLine = pConsole->GetMethod(name, callingConvention, *pRetType, paramTypes);
        }

        MethodNameMetadata const *pWriteLineName = NULL;
        pWriteLineName = pWriteLine->GetMethodName();

        ASSERT_STREQ(L"WriteLine", pWriteLineName->GetName().c_str());
    }
}
